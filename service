#!/usr/bin/python
import subprocess, time, os, requests, traceback, threading, sys, json
from hosted import device, node, config
from select import select
from evdev import ecodes, InputDevice, list_devices
from evdev.events import KeyEvent

config.restart_on_update()
num_key = {'KEY_KP0','KEY_KP1','KEY_KP2','KEY_KP3','KEY_KP4','KEY_KP5','KEY_KP6','KEY_KP7','KEY_KP8','KEY_KP9'}
global key_down = 1
global key_val = 0 
global key_state = ""

def photo_mode():
    node.send('/photomode:')
    width, height = device.screen_resolution

    for pic_num in range(1, 5):
        print("taking picture %d of 4" % pic_num)
        countdown = config['countdown_%d' % pic_num]
        target = config.order[pic_num-1]
        capture = subprocess.Popen([
            "raspistill",
            "-o", "picture%d.jpg" % target,
            "-p", "%d,0,%d,%d" % (width/2,width/2, height/2),
            "-t", str(countdown * 1000), # timeout in ms
            "-fp", # fullscreen preview
            "-w", str(width/2),
            "-h", str(height/2),
        ])
        node.send('/snap:%d,%d' % (pic_num, countdown))
        capture.wait()

    node.send('/collage:')
    if config.upload_url:
        try:
            r = requests.post(
                url = config.upload_url,
                files = {
                    'pic1': open('picture1.jpg', 'rb'),
                    'pic2': open('picture2.jpg', 'rb'),
                    'pic3': open('picture3.jpg', 'rb'),
                    'pic4': open('picture4.jpg', 'rb'),
                },
                stream = True,
            )
            r.raise_for_status()
            if r.headers['content-type'] != "image/png":
                raise Exception("Not a PNG")
            node.write_file('dynamic.png', r.raw.read())
        except Exception as err:
            traceback.print_exc()

    time.sleep(config.collage_time)
    for pic_num in range(1, 5):
        os.unlink("picture%d.jpg" % pic_num)
    if os.path.exists('dynamic.png'):
        os.unlink("dynamic.png")
    node.send('/loop:')

devices = {}
def update_devices():
    new = set(list_devices("/dev/input/"))
    old = set(devices.keys())

    for device_name in new - old:
        devices[device_name] = InputDevice(device_name)

    for device_name in old - new:
        del devices[device_name]

    
    
    
def device_event(event):
#    print >>sys.stderr, event

#    if event.code in ecodes.BTN:
#        btn = ecodes.BTN[event.code]
#        if not isinstance(btn, list):
#            btn = [btn]
#        for name in btn:
#            node.send('/event/pad:%s' % json.dumps(dict(
#                key = name.replace("BTN_", "pad_").lower(),
#                action = {
#                    KeyEvent.key_up: "up",
#                    KeyEvent.key_down: "down",
#                }[event.value],
#            )))
    
    if event.type == ecodes.EV_KEY and event.code in ecodes.KEY:
        if ecodes.KEY[event.code] in num_key and event.value == key_down:
               keyin_val = int(ecodes.KEY[event.code][-1:])
               print >>sys.stderr, "Keyin " 
               print >>sys.stderr, keyin_val
               #key_time = now 
               key_state = "input"
               if key_val > 99:
                   key_val = keyin_val
               else:
                   key_val = (key_val *10 ) + keyin_val            
               print >>sys.stderr, "Key " 
               print >>sys.stderr, key_val
               node.send('/renner_nr:%s' % key_val)
               node.send('/renner_nr_state:%s' % key_state)
def monitor_input():
    update_devices()
    r, w, e = select(devices.values(), [], [], 1)
    for event in r:
        try:
            for ev in event.read():
                device_event(ev)
        except IOError:
            # device disconnected
            pass

def monitor_gpio():
#    node.send('/loop:')
    pin, inverted = config.pin
    device.gpio.monitor(pin, invert=inverted)
    for _, state in device.gpio.poll_forever():
        if state:
            photo_mode()

def run_in_thread(fn):
    def wrap():
        try:
            while 1:
                fn()
        except Exception:
            traceback.print_exc()
            os._exit(1)
    thread = threading.Thread(target=wrap)
    thread.daemon = True
    thread.start()
            
            
if __name__ == "__main__":
    node.send('/loop:')
    run_in_thread(monitor_gpio)
    run_in_thread(monitor_input)
    
    while 1: time.sleep(1000)
